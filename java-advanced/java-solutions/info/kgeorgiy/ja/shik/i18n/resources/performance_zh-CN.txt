作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->

作业1. 文件爬取
开发一个计算文件哈希和的Walk类。
启动格式
java Walk<输入文件><输出文件>
输入文件包含要绕过的文件列表。
输出文件必须为每个文件包含一行。 字符串格式:
<十六进制哈希总和><文件路径>
要计算哈希总和，请使用64位版本的PJW算法。
如果在读取文件时发生错误，请指定000000000000000作为其哈希总和。
输入和输出文件的编码是UTF-8。
如果输出文件的父目录不存在，则必须创建相应的路径。
文件大小可能超过RAM大小。
示例

输入文件

样品/1
样品/12
样品/123
样本/1234
样品/1
样本/二进制
样本/no-such-file

输出文件

0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
0000000000000031样本/1
005501015554abff样本/二进制
0000000000000000样本/no-such-file

困难的选择:
开发一个RecursiveWalk类，用于计算目录中文件的哈希值
输入文件包含要爬网的文件和目录的列表。 目录以递归方式遍历。
示例

输入文件

样本/二进制
样品
样本/no-such-file

输出文件

005501015554abff样本/二进制
0000000000000031样本/1
0000000000003132样本/12
0000000000313233样本/123
0000000031323334样本/1234
005501015554abff样本/二进制
0000000000000000样本/no-such-file

完成任务时，要注意:
设计和异常处理，错误诊断。
即使发生错误，程序也必须正确终止。
正确的I/O操作。
没有资源泄漏。
任务的设计要求。
检查任务的源代码。
所有代码都必须在信息中。kgeorgiy是啊姓。走包.
家庭作业测试

作业2. 设置在数组上
开发实现不可变有序集的ArraySet类。
ArraySet类必须实现SortedSet（简单版本）或NavigableSet（复杂版本）接口。
对集合的所有操作必须以尽可能高的渐近效率执行。
完成任务时，要注意:
标准集合的使用。
摆脱重复的代码。
作业3. 学生
开发一个StudentDB类，用于搜索student数据库。
StudentDB类必须实现StudentQuery接口（简单版本）或GroupQuery（复杂版本）。
每个方法必须由一个语句组成。 在这种情况下，长语句应该分成几行。
执行任务时，应注意:
lambda表达式和线程的使用;
摆脱重复的代码。
4. 实施者作业分配
实现Implementor类，它将生成类和接口的实现。
命令行参数：生成实现的类/接口的全名。
因此，必须生成具有Impl后缀的类的java代码，扩展（实现）指定的类（接口）。
生成的类必须编译没有错误。
生成的类不能是抽象的。
生成的类的方法应该忽略它们的参数并返回默认值。
任务中有三个选项:
Simple-Implementor应该只能实现接口（但不能实现类）。 不需要泛型支持。
复杂-实现者必须能够实现类和接口。 不需要泛型支持。
奖励-实现者必须能够实现泛型类和接口。 生成的代码必须具有正确的类型参数，而不是生成UncheckedWarning。
作业5。 Jar实现器
创建它。一个jar文件，包含编译的实现器和相关的类。
创建。jar文件必须使用java-jar命令运行。
可运行。jar文件必须接受与Implementor类相同的命令行参数。
修改实现器，以便在使用-jar-class-name参数运行时，该文件。它生成的罐子。一个jar文件，其中包含相应类（接口）的实现。
为了验证，除了源代码之外，还必须提供以下内容:
用于创建启动的脚本。jar文件，包括清单源代码;
可运行。jar文件。
这个作业只与前一个作业一起给出。 您将无法单独通过之前的家庭作业。
一个艰难的选择。 解决方案必须模块化。
作业6. Javadoc
使用Javadoc记录Implementor类和相关类。
必须记录所有类和所有类成员（包括private）。
应该在没有警告的情况下生成文档。
生成的文档必须包含对标准库类的正确引用。
为了验证，除了源代码，您还必须提交:
生成文档的脚本;
生成的文档。
这个作业只与前一个作业一起给出。 你将无法单独通过之前的家庭作业。
家庭作业7. 迭代并发
实现IterativeParallelism类，它将处理多个线程中的列表。
在一个简单的版本中，应该实现以下方法:
minimum（线程，列表，比较器）—第一个最小值;
最大值（线程，列表，比较器）—第一个最大值;
all(threads,list,predict)-检查列表的所有元素是否满足谓词;
any(threads,list,predict)-检查是否存在满足谓词的列表项。
在复杂版本中，应另外实现以下方法:
filter(threads,list,predict)-返回包含满足谓词的元素的列表;
map(threads,list,function)-返回包含函数应用结果的列表;
join(threads,list)-列表项的字符串表示的连接。
Threads参数传递给所有函数—计算中应该使用多少个线程。 可以预期线程的数量并不大。
您不应该依赖于传递的比较器，谓词和函数快速工作的事实。
执行任务时不能使用并发实用程序。
建议想想monoids与任务有什么关系。
作业8。 并行启动
编写实现Parallelmapperimpl接口的ParallelMapperImpl类。
公共接口ParallelMapper扩展AutoCloseable {
<T,R>列表<R>地图(
功能<？ 超T，？ 延伸R>f,
列表<？ 扩展T>args
）抛出InterruptedException;

@复盖
void close()抛出InterruptedException;
}
Run方法必须在每个指定参数(args)上并行计算函数f。
Close方法应该停止所有工作线程。
ParallelMapperImpl(int threads)构造函数创建可用于并行化的工作线程的线程。
单个ParallelMapperImpl可以在同一时间被多个客户端访问。
要执行的任务必须在队列中累积，并按照先到先得的原则进行处理。
在执行中不应该有积极的期望。
修改IterativeParallelism类，使其可以使用ParallelMapper。
添加IterativeParallelism(ParallelMapper)构造函数)
类的方法应该将工作分成片段的线程，并使用ParallelMapper执行它们。
如果有ParallelMapper，IterativeParallelism本身不应该创建新的线程。
应该可以使用相同的ParallelMapper同时启动和运行多个客户端。
作业9。 网络爬虫
编写一个线程安全的WebCrawler类，它将递归地对网站进行爬网。
WebCrawler类必须具有
一个公共WebCrawler构造函数（Downloader下载器，int downloads，int extractors，int perHost)

下载器允许您下载页面并从中提取链接;
下载-同一时间下载的最大页面数;
提取器—同一时间从中提取链接的最大页面数;
perHost-从单个主机同时加载的最大页面数。 要确定主机，请使用测试中的URLUtils类的getHost方法。
WebCrawler类必须实现
爬虫公共接口爬虫扩展AutoCloseable接口 {
结果下载（字符串url，int深度);

无效关闭();
}

Download方法应递归地抓取从指定URL开始到指定深度的页面，并返回已下载页面和文件的列表。 例如，如果深度为1，则只应加载指定的页面。 如果深度为2，则指定页面及其链接的页面和文件，依此类推。 此方法可以在多个线程中并行调用。
页面加载和处理（链接提取）应尽可能并行执行，同时考虑到对同时加载的页面数量（包括来自单个主机）和从中加载链接的页面的限制。
对于并行化，允许创建最多下载+提取器的辅助线程。
禁止在同一抓取（下载）内从同一页面下载和/或提取链接。
Close方法必须终止所有辅助线程。
要加载页面，必须使用构造函数的第一个参数传递的下载器。
公共接口下载器 {
公共文档下载（最终字符串url）抛出IOException;
}

下载方法在其URL处加载文档。
该文档允许您在加载的页面上获取链接:
公共接口文档 {
List<String>extractLinks()抛出IOException;
}

文档返回的链接是绝对的，具有http或https模式。
必须实现main方法才能从命令行运行爬网。
命令行
WebCrawler url[depth[downloads[extractors[perHost]]]]

要加载页面，您需要使用测试中的CachingDownloader实现。
任务版本
简单—您不需要考虑从单个主机同时下载数量的限制（perHost>=downloads）。
完全-必须考虑所有限制。
奖金-在宽度上做一个平行的边缘。
作业10. HelloUDP
实现通过UDP进行通信的客户端和服务器。
HelloUDPClient类应向服务器发送请求，接受结果，并将其输出到控制台。
命令行参数:
运行服务器的计算机的名称或ip地址;
发送请求的端口号;
请求前缀（字符串);
并发请求线程数;
每个线程中的请求数。
请求必须在指定数量的线程中同时发送。 每个线程必须等待其请求被处理，并将请求本身及其处理结果输出到控制台。 如果请求未被处理，则需要再次发送。
请求应根据<请求前缀>方案<流编号>_<流中的请求编号>形成。
HelloUDPServer类必须接受并响应HelloUDPClient类发送的任务。
命令行参数:
接收请求的端口号;
将处理请求的工作线程数。
对请求的响应必须是Hello,<request text>。
如果服务器没有时间处理请求，请求的接收可能会暂时暂停。
家庭作业11. 个人
将与个人合作的能力添加到银行应用程序中。
您可以要求个人提供名字、姓氏和护照号码。
必须使用序列化机制传输本地个人(LocalPerson)。
远程个人(RemotePerson)必须使用远程对象进行传输。
应该可以通过护照号码搜索个人，并选择要返回的人的类型。
应该可以根据个人的数据创建有关个人的记录。
个人可能有多个帐户，必须向其授予访问权限。
具有subId的个人帐户必须与具有passport:subId类型id的银行帐户相匹配。
对银行帐户所做的更改（创建和更改余额）应对所有相关的远程人员可见，并且仅对在此更改后创建的本地人员可见。
通过RemotePerson所做的帐户更改应立即全局应用，通过LocalPerson所做的更改应仅在本地应用于该特定LocalPerson。
实现演示与个人合作的应用程序。
命令行参数：名字，姓氏，个人的护照号码，帐号，帐户金额的更改。
如果没有关于指定个人的信息，则必须添加它。 否则，必须检查其数据。
如果个人没有指定数量的帐户，则会使用零余额创建帐户。
更新帐户金额后，新余额应显示在控制台上。
编写测试，测试银行和应用程序的上述行为。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
使用的库的jar文件应放在您的存储库的lib目录中。
您不能使用通过main运行的自写框架和测试。
困难的选择
测试不应指望是否存在正在运行的RMI注册表。
创建运行测试的BankTests类。
创建一个运行BankTests的脚本，如果成功则返回0，如果不成功则返回1的代码（状态）。
创建使用测试框架的标准方法运行测试的脚本。 返回代码必须与上一段相同。
作业12. HelloNonblockingUDP
仅使用非阻塞I/O通过UDP实现客户端和服务器通信。
HelloUDPNonblockingClient类应该具有类似于HelloUDPClient的功能，但不创建新线程。
HelloUDPNonblockingServer类必须具有类似于HelloUDPServer的功能，但所有套接字操作必须在单个线程中执行。
实现不应该有积极的期望，包括通过选择器。
注意突出新旧实现的通用代码。
奖金选项. 客户端和服务器可以在开始工作之前分配O（线程数）的内存。 禁止在操作期间分配额外的内存。
家庭作业13. 文本统计
创建一个TextStatistics应用程序，用于分析不同语言的文本。
命令行参数:
文
区域设置，输出区域设置,
文
文件，报告文件。
支持的文本区域设置：系统中可用的所有区域设置。
支持的输出语言环境：俄语和英语。
这些文件是UTF-8编码的。
统计应按以下类别计算:
句子,
词,
数字,
钱,
日期。
对于每个类别，应收集以下统计数据:
出现次数,
不同值的数量,
最小值,
最大值,
最小长度,
最大长度,
平均值/长度。
样本报告:
文件来分析"的输入。txt"
汇总统计
优惠数量:43.
字数：275.
数:40.
数量:3.
日期数:3.
报价统计
提供数量:43(43不同).
最低报价："命令行参数：文本区域设置，输出区域设置，文本文件，报告文件。".
最大报价:"数:40.".
最小句子长度：13（"日期数：3。").
最大句长：211（"GK：如果你在这里放一个真实的句子，这个过程不会收敛"）。
平均句长：55,465。
按单词统计
字数：275（157不同）。
最小字："GK"。
最大字："语言"。
最小字长：1（"c"）。
最大字长：14（"TextStatistics"）。
平均字长：6.72。
按数字统计
数字数量：40（24个不同）。
最小数量:-12345.0.
最大数量:12345.67.
平均人数:207,676.
金额统计
总和数：3（3个不同）。
最低金额：￥100.00。
最高金额：￥345.67。
平均金额：￥222.83。
按日期统计
日期数:3(3不同).
最低日期：2021年5月22日。
最大日期：2021年6月8日。
平均日期：2021年5月30日。
您可以指望整个文本存储在内存中。
完成任务时，要注意:
分解消息以进行本地化
按性别和数字匹配消息
编写测试应用程序的上述行为的测试。
要实现测试，我们建议使用JUnit（教程）。 在测试中可以找到许多使用示例。
如果您熟悉另一个测试框架（例如，TestNG），则可以使用它。
您不能使用通过main运行的自写框架和测试。

<-------------------------------------------------------------------------------------------------------->