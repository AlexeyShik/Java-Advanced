xHomework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->

Homework 1. File Crawling
Develop a Walk class that calculates the hash sums of files.
Launch format
java Walk <input file> <output file>
The input file contains a list of files that you want to bypass.
The output file must contain one line for each file. String format:
<hexadecimal hash sum> <file path>
To calculate the hash sum, use the 64-bit version of the PJW algorithm.
If errors occur when reading the file, specify 0000000000000000 as its hash sum.
The encoding of the input and output files is UTF-8.
If the parent directory of the output file does not exist, then the corresponding path must be created.
The file sizes may exceed the RAM size.
Example

Input file

samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file

Output file

0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
0000000000000031 samples/1
005501015554abff samples/binary
0000000000000000 samples/no-such-file

Difficult option:
Develop a RecursiveWalk class that calculates the hash sums of files in directories
The input file contains a list of files and directories that you want to crawl. Directories are traversed recursively.
Example

Input file

samples/binary
samples
samples/no-such-file

Output file

005501015554abff samples/binary
0000000000000031 samples/1
0000000000003132 samples/12
0000000000313233 samples/123
0000000031323334 samples/1234
005501015554abff samples/binary
0000000000000000 samples/no-such-file

When completing the task, you should pay attention to:
Design and exception handling, error diagnostics.
The program must terminate correctly even in the event of an error.
Correct I / O operation.
No resource leakage.
Requirements for the design of the task.
The source code of the task is checked.
All code must be in the info.kgeorgiy.ja.surname.walk package.
Tests for homework assignments

Homework 2. Set on an array
Develop an ArraySet class that implements an immutable ordered set.
The ArraySet class must implement the SortedSet (simple version) or NavigableSet (complex version) interface.
All operations on sets must be performed with the highest possible asymptotic efficiency.
When completing the task, you should pay attention to:
Use of standard collections.
Getting rid of repetitive code.
Homework 3. Students
Develop a StudentDB class that searches the student database.
The StudentDB class must implement the StudentQuery interface (simple version) or GroupQuery (complex version).
Each method must consist of exactly one statement. In this case, long statements should be split into several lines.
When performing the task, you should pay attention to:
the use of lambda expressions and threads;
getting rid of repetitive code.
4. Implementor Homework Assignment
Implement the Implementor class, which will generate implementations of classes and interfaces.
Command-line argument: The full name of the class / interface to generate the implementation for.
As a result, the java code of the class with the Impl suffix must be generated, extending (implementing) the specified class (interface).
The generated class must compile without errors.
The generated class must not be abstract.
Methods of the generated class should ignore their arguments and return default values.
There are three options in the task:
Simple-Implementor should be able to implement only interfaces (but not classes). Generics support is not required.
Complex-The Implementor must be able to implement both classes and interfaces. Generics support is not required.
Bonus — The Implementor must be able to implement generic classes and interfaces. The generated code must have the correct type parameters and not generate UncheckedWarning.
Homework 5. Jar Implementor
Create it .a jar file containing the compiled Implementor and associated classes.
Created .the jar file must be run with the java-jar command.
Runable .the jar file must accept the same command-line arguments as the Implementor class.
Modify the Implementor so that when running with the-jar-class-name arguments, the file.the jar it generated .a jar file with the implementation of the corresponding class (interface).
For verification, in addition to the source code, the following must also be presented:
a script for creating a startup .jar file, including the manifest source code;
runable .jar file.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
A difficult option. The solution must be modularized.
Homework 6. Javadoc
Document the Implementor class and related classes using Javadoc.
All classes and all class members, including private, must be documented.
Documentation should be generated without warnings.
The generated documentation must contain correct references to the standard library classes.
For verification, in addition to the source code, you must also submit:
script for generating documentation;
generated documentation.
This homework assignment is given only together with the previous one. You will not be able to pass the previous homework separately.
Homework assignment 7. Iterative concurrency
Implement the IterativeParallelism class, which will process lists in multiple threads.
In a simple version, the following methods should be implemented:
minimum(threads, list, comparator) — the first minimum;
maximum(threads, list, comparator) — the first maximum;
all(threads, list, predict) — checking that all elements of the list satisfy the predicate;
any(threads, list, predict) - checks that there is a list item that satisfies the predicate.
In the complex version, the following methods should be additionally implemented:
filter(threads, list, predict) - return a list containing elements that satisfy the predicate;
map(threads, list, function) - return a list containing the results of the function application;
join (threads, list) - concatenation of string representations of list items.
The threads parameter is passed to all functions — how many threads should be used in the calculation. You can expect that the number of threads is not large.
You should not rely on the fact that the passed comparators, predicates, and functions work quickly.
You cannot use Concurrency Utilities when executing a task.
It is recommended to think about what the monoids have to do with the task.
Homework 8. Parallel startup
Write a ParallelMapperImpl class that implements the ParallelMapper interface.
public interface ParallelMapper extends AutoCloseable {
<T, R> List<R> map(
Function<? super T, ? extends R> f,
List<? extends T> args
) throws InterruptedException;

@Override
void close() throws InterruptedException;
}
The run method must compute the function f on each of the specified arguments (args) in parallel.
The close method should stop all worker threads.
The ParallelMapperImpl(int threads) constructor creates threads of worker threads that can be used for parallelization.
A single ParallelMapperImpl can be accessed by multiple clients at the same time.
Tasks for execution must be accumulated in the queue and processed on a first-come, first-served basis.
There should be no active expectations in the implementation.
Modify the IterativeParallelism class so that it can use ParallelMapper.
Add the IterativeParallelism(ParallelMapper) constructor)
The methods of the class should divide the work into threads of fragments and execute them using ParallelMapper.
If there is a ParallelMapper, IterativeParallelism itself should not create new threads.
It should be possible to simultaneously start and run multiple clients using the same ParallelMapper.
Homework 9. Web Crawler
Write a thread-safe WebCrawler class that will recursively crawl sites.
The WebCrawler class must have
a public WebCrawler constructor (Downloader downloader, int downloads, int extractors, int perHost)

downloader allows you to download pages and extract links from them;
downloads — maximum number of pages downloaded at the same time;
extractors — the maximum number of pages from which links are extracted at the same time;
perHost — the maximum number of pages loaded simultaneously from a single host. To determine the host, use the getHost method of the URLUtils class from the tests.
The WebCrawler class must implement
the Crawler public interface Crawler extends AutoCloseable interface {
Result download(String url, int depth);

void close();
}

The download method should recursively crawl pages starting from the specified URL to the specified depth and return a list of downloaded pages and files. For example, if the depth is 1, then only the specified page should be loaded. If the depth is 2, then the specified page and the pages and files it links to, and so on. This method can be called in parallel in multiple threads.
Page loading and processing (link extraction) should be performed as much as possible in parallel, taking into account the restrictions on the number of pages loaded simultaneously (including from a single host) and the pages from which links are loaded.
For parallelization, it is allowed to create up to downloads + extractors auxiliary threads.
It is forbidden to download and/or extract links from the same page within the same crawl (download).
The close method must terminate all auxiliary threads.
To load pages, the Downloader passed by the first argument of the constructor must be used.
public interface Downloader {
public Document download(final String url) throws IOException;
}

The download method loads the document at its URL.
The document allows you to get links on the loaded page:
public interface Document {
List<String> extractLinks() throws IOException;
}

The links returned by the document are absolute and have an http or https schema.
The main method must be implemented to run the crawl from the command line.
Command Line
WebCrawler url [depth [downloads [extractors [perHost]]]]

To load pages, you need to use the CachingDownloader implementation from the tests.
Task versions
Simple — you do not need to take into account the restrictions on the number of simultaneous downloads from a single host (perHost >= downloads).
Full-all restrictions must be taken into account.
Bonus — make a parallel rim in width.
Homework 10. HelloUDP
Implement a client and server that communicate over UDP.
The HelloUDPClient class should send requests to the server, accept the results, and output them to the console.
Command line arguments:
the name or ip address of the computer running the server;
port number to send requests to;
request prefix (string);
number of concurrent request threads;
the number of requests in each thread.
Requests must be sent simultaneously in the specified number of threads. Each thread must wait for its request to be processed and output the request itself and the result of its processing to the console. If the request was not processed, you need to send it again.
Requests should be formed according to the <request prefix>scheme<stream number>_<request number in the stream>.
The HelloUDPServer class must accept and respond to tasks sent by the HelloUDPClient class.
Command line arguments:
the number of the port on which requests will be received;
the number of worker threads that will process requests.
The response to the request must be Hello, < request text>.
If the server does not have time to process requests, the reception of requests may be temporarily suspended.
Homework assignment 11. Individuals
Add the ability to work with individuals to the banking application.
You can request a first name, last name, and passport number from an individual.
Local individuals (LocalPerson) must be transmitted using the serialization mechanism.
Remote individuals (RemotePerson) must be transmitted using remote objects.
It should be possible to search for an individual by the passport number, with the choice of the type of person to be returned.
It should be possible to create a record about an individual based on their data.
An individual may have multiple accounts to which access must be granted.
An individual's account with a subId must match a bank account with an id of the type passport: subId.
Changes made to the bank account (creating and changing the balance) should be visible to all the relevant RemotePerson, and only to those LocalPerson that were created after this change.
Changes to accounts made via RemotePerson should be applied globally immediately, and changes made via LocalPerson should only be applied locally for that particular LocalPerson.
Implement an application that demonstrates working with individuals.
Command line arguments: first name, last name, passport number of an individual, account number, change of the account amount.
If there is no information about the specified individual, then it must be added. Otherwise, its data must be checked.
If an individual does not have an account with the specified number, it is created with a zero balance.
After updating the account amount, the new balance should be displayed on the console.
Write tests that test the above behavior of both the bank and the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
The jar files of the used libraries should be placed in the lib directory of your repository.
You can't use self-written frameworks and tests that run through main.
Difficult option
Tests should not count on the presence of a running RMI Registry.
Create a BankTests class that runs the tests.
Create a script that runs BankTests and returns a code (status) of 0 if successful and 1 if unsuccessful.
Create a script that runs tests using the standard approach for your test framework. The return code must be the same as in the previous paragraph.
Homework 12. HelloNonblockingUDP
Implement client and server communication over UDP using only non-blocking I / O.
The HelloUDPNonblockingClient class should have functionality similar to HelloUDPClient, but without creating new threads.
The HelloUDPNonblockingServer class must have functionality similar to HelloUDPServer, but all socket operations must be performed in a single thread.
The implementation should not have active expectations, including through the Selector.
Pay attention to highlighting the common code of the old and new implementation.
Bonus option. The client and server can allocate O(number of threads) of memory before starting work. It is forbidden to allocate additional memory during operation.
Homework assignment 13. Text statistics
Create a TextStatistics application that analyzes texts in different languages.
Command line arguments:
text
locale, output locale,
text
file, report file.
Supported text locales: all locales available in the system.
Supported output locales: Russian and English.
The files are UTF-8 encoded.
Statistics should be calculated in the following categories:
sentences,
words,
numbers,
money,
dates.
For each category, the following statistics should be collected:
number of occurrences,
number of different values,
minimum value,
maximum value,
minimum length,
maximum length,
average value/length.
Sample report:
File to analyze "input.txt"
Summary statistics
Number of offers: 43.
Number of words: 275.
Number of numbers: 40.
Number of amounts: 3.
Number of dates: 3.
Offer statistics
Number of offers: 43 (43 different).
Minimum offer: "Command line arguments: text locale, output locale, text file, report file.".
Maximum offer: "Number of numbers: 40.".
Minimum sentence length: 13 ("Number of dates: 3.").
Maximum sentence length: 211 ("GK: if you put a real sentence here, the process will not converge").
Average sentence length: 55,465.
Statistics by words
Number of words: 275 (157 different).
Minimum word: "GK".
Maximum word: "languages".
Minimum word length: 1 ("c").
Maximum word length: 14 ("TextStatistics").
Average word length: 6.72.
Statistics by numbers
Number of numbers: 40 (24 different).
Minimum number: -12345.0.
Maximum number: 12345.67.
Average number: 207,676.
Statistics on amounts of money
Number of sums: 3 (3 different).
Minimum amount: ¤100.00.
Maximum amount: ¤345.67.
Average amount: ¤222.83.
Statistics by date
Number of dates: 3 (3 different).
Minimum date: May 22, 2021.
Maximum date: June 8, 2021.
Average date: May 30, 2021.
You can count on the entire text being stored in memory.
When completing the task, you should pay attention to:
Decomposition of messages for localization
Matching messages by gender and number
Write tests that test the above behavior of the application.
To implement tests, we recommend using JUnit (Tutorial). Many usage examples can be found in the tests.
If you are familiar with another test framework (for example, TestNG), you can use it.
You can't use self-written frameworks and tests that run through main.

<-------------------------------------------------------------------------------------------------------->